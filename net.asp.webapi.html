<!DOCTYPE html>
<html>
<head>
  <title>WebAPI</title>
  <link href="remarks.css" rel="stylesheet"> </link>
  <meta charset="windows-1251"></meta>
</head>
<body>
  <!-- Roadmap -->
  <section>
    <header><h2>Roadmap</h2></header>
  </section>
  <!-- Assemblies -->
  <section>
    <header><h2>Assemblies</h2></header>
    <table>
      <tbody>
        <tr><td>System.Net.Http.dll</td></tr>
        <tr><td>System.Net.Http.Formatting.dll</td></tr>
        <tr><td>System.Net.Http.WebRequest.dll</td></tr>

        <tr><td>System.Web.Http.dll</td></tr>
        <tr><td>System.Web.Http.WebHost.dll</td></tr>
        <tr><td>System.Web.Http.Owin.dll</td></tr>
        <tr><td>System.Web.Http.SelfHost.dll</td></tr>
        
        <tr><td>Microsoft.Owin.Host.SystemWeb</td></tr>
      </tbody>
    </table>
  </section>
  <!-- Namespaces -->
  <section>
    <h2>Namespaces</h2>
    <table>
      <tbody>
        <tr><td>System.Net.Http</td><td></td></tr>
        <tr><td>System.Net.Http.Formatting</td><td></td></tr>
        <tr><td>System.Net.Http.Headers</td><td></td></tr>
        <tr><td>System.Web.Http</td><td>Contains definition of core classes of Web API </td></tr>
        <tr><td>System.Web.Http.Controllers</td><td>IHttpController, ServicesContainer</td></tr>
        <tr><td>System.Web.Http.Dependencies</td><td>Dependency injection, dependency resolver</td></tr>
        <tr>
          <td>System.Web.Http.Dispatcher</td>
          <td>
            This namespace contains classes that manage the Web API request
            dispatch process from receiving a request from the hosting platform through to selecting and executing a controller
          </td>
        </tr>
        <tr>
          <td>System.Web.Http.Filters</td>
          <td>
            This namespace contains the filter support, which allows
            for additional logic to be inserted into the dispatch process.
          </td>
        </tr>
        <tr>
          <td>System.Web.Http.Metadata</td>
          <td>
            This namespace contains classes that provide descriptions of model classes.
            These classes are not used directly but are presented through context objects in dispatch process or when data
            provided by a client is being validated.
          </td>
        </tr>
        <tr>
          <td>System.Web.Http.ModelBinding</td>
          <td>
            Contains classes responsible for creating objects and values
            from HTTP requests that can be used by action methods.
          </td>
        </tr>
        <tr><td>System.Web.Http.Owin</td><td></td></tr>
        <tr>
          <td>System.Web.Http.Results</td>
          <td>
            Contains classes that implement the IHttpActionResult interface,
            which is used by action methods to describe the responses that will be sent to a client.
          </td>
        </tr>
        <tr><td>System.Web.Http.Routing</td><td></td></tr>
        <tr><td>System.Web.Http.Validation</td><td></td></tr>
        <tr>
          <td>System.Web.Http.ValueProviders</td>
          <td>
            Contains classes that are used  to retrieve values from
            requests so that they can be used with action methods.
          </td>
        </tr>
        <tr><td>System.Web.Http.WebHost</td><td></td></tr>
      </tbody>
    </table>
  </section>
  <!-- Terms  -->
  <section>
    <header><h2>Terms</h2></header>
    <table>
      <thead>
        <tr><td>Term</td><td>Description</td></tr>
      </thead>
      <tbody>
        <tr><td>REST</td><td>Representation state transfer</td></tr>
        <tr><td>RMM</td><td>REST Maturity Model</td></tr>
        <tr><td>OWIN</td><td>Open Web Interface for .NET</td></tr>
        <tr><td>controller context</td></tr>
        <tr><td>RouteData</td></tr>
        <tr><td>ModelState</td></tr>
        <tr><td>Url helper class</td></tr>
        <tr><td>Content negotiation</td></tr>
        <tr><td>Сustom message handlers</td><td>can be added between HttpServer and HttpRoutingDispath for custom processing </td></tr>
        <tr><td>Web API filters</td></tr>
        <tr><td>Value provider</td><td>Used for bind simple data type</td></tr>
        <tr>
          <td>Model binder</td>
          <td>
            Provides a model binder for a given type. Model binders work only
            with value providers, meaning that data values are obtained from the URL
          </td>
        </tr>
        <tr><td>Media type formatters</td><td>used for serializing and deserealizing request body</td></tr>
      </tbody>
    </table>
  </section>
  <!-- Configuration  -->
  <section>
    <header><h2>Configuration</h2></header>
    <b>static class GlobalConfiguration</b>
    <div>
      <table>
        <thead>
          <tr><th>Type</th><th>Property</th></tr>
        </thead>
        <tbody>
          <tr><td>HttpConfiguration</td><td>Configuration</td></tr>
          <tr><td>HttpMessageHandler</td><td>DefaultHandler</td></tr>
          <tr><td>HttpServer</td><td>DefaultServer</td></tr>
        </tbody>
      </table>
    </div>
    <section>
      <header><h4>Properties defined by the HttpConfiguration class</h4></header>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>DependencyResolver</td></tr>
          <tr><td>Filters</td></tr>
          <tr><td>Formatters</td></tr>
          <tr><td>IncludeErrorDetailPolicy</td></tr>
          <tr><td>MessageHandlers</td><td>collection of DelegatingHandler</td></tr>
          <tr><td>ParameterBindingRules</td></tr>
          <tr><td>Properties</td></tr>
          <tr><td>Routes</td></tr>
          <tr><td>Services</td><td>ServicesContainer provides a container for services used by ASP.NET Web API</td></tr>
          <tr><td></td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <header><h4>Methods (extensions) of HttpConfiguration</h4></header>
      <table>
        <thead>
        </thead>
        <tbody>
          <tr><td>BindParameter</td></tr>
          <tr><td>MapHttpAttributeRoutes</td></tr>
          <tr><td>SuppressHostPrincipal</td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <header><h4>Services used by ASP.Net WebAPI</h4></header>
      ServiceContainer class contains a lot of methods which return concrete services
      HttpConfiguration.Services (ServicesContainer)
      <table>
        <thead></thead>
        <tbody>
          <tr><td>IHttpActionInvoker</td><td>GetActionInvoker</td></tr>
          <tr><td>IHttpActionSelector</td><td>GetActionSelector</td></tr>
          <tr><td>IActionValueBinder</td><td>GetActionValueBinder</td></tr>
          <tr><td>IApiExplorer</td><td>GetApiExplorer</td></tr>
          <tr><td>IAssembliesResolver</td><td>GetAssembliesResolver</td></tr>
          <tr><td>IBodyModelValidator</td><td>GetBodyModelValidator</td></tr>
          <tr><td>IContentNegotiator</td><td>GetContentNegotiator</td></tr>
          <tr><td>IDocumentationProvider</td><td>GetDocumentationProvider</td></tr>
          <tr><td>IExceptionHandler</td><td>GetExceptionHandler</td></tr>
          <tr><td>IEnumerable &lt;IExceptionLogger&gt;</td><td> GetExceptionLoggers</td></tr>
          <tr><td>IEnumerable&lt;IFilterProvider&gt; </td><td>GetFilterProviders</td></tr>
          <tr><td>IHostBufferPolicySelector </td><td>GetHostBufferPolicySelector</td></tr>
          <tr><td>IHttpControllerActivator </td><td>GetHttpControllerActivator</td></tr>
          <tr><td>IHttpControllerSelector </td><td>GetHttpControllerSelector</td></tr>
          <tr><td>IHttpControllerTypeResolver </td><td>GetHttpControllerTypeResolver</td></tr>
          <tr><td>IEnumerable&lt;ModelBinderProvider&gt; </td><td>GetModelBinderProviders</td></tr>
          <tr><td>ModelMetadataProvider </td><td>GetModelMetadataProvider</td></tr>
          <tr><td>IEnumerable&lt;ModelValidatorProvider&gt;</td><td>GetModelValidatorProviders</td></tr>
          <tr><td>ITraceManager </td><td>GetTraceManager</td></tr>
          <tr><td>ITraceWriter</td><td>GetTraceWriter</td></tr>
          <tr><td>IEnumerable&lt;ValueProviderFactory&gt; </td><td>GetValueProviderFactories</td></tr>
        </tbody>
      </table>
    </section>
  </section>
  <!-- Dependency  -->
  <section>
    <header><h2>Dependency injector/resolver</h2></header>
    <section>
      <header>Interfaces and classes</header>
      <ul>
        <li>IDependencyResolver</li>
        <li>IDependencyScope</li>
        <li>Global.Configuration.</li>
      </ul>
    </section>
    <!-- Ninject -->
    <section>
      <header><h3>Configuring Web API Dependency Injection (Ninject)</h3></header>
      <section>
        <header>Namespaces</header>
        <dl>
          <dt>NuGet packages</dt>
          <dd>
            <ol>
              <li>Ninject</li>
              <li>Ninject.Web.Common</li>
              <li>Ninject.Web.Common.WebHost</li>
            </ol>
          </dd>
          <dt>Edit NinjectWebCommon.cs</dt>
          <dd></dd>
        </dl>

      </section>
      <section>
        <h4>Process</h4>
        <ol>
          <li>Create a NinjectResolver class which implements System.Web.Http.Dependencies.IDependencyResolver</li>
          <li>
            Configure Ninject through
            GlocalConfiguration.Configuration.DependencyResolver = new NinjectResolver();
          </li>
          <li>
            To integrate Ninject with MVC application NinjectResolver have to implement
            System.Web.Mvc.DependencyResolver (IDependencyResolver)
          </li>
        </ol>
      </section>
      <section>
        <h4>Three types of object created by dependecy injection</h4>
        <ul>
          <li>Singleton</li>
          <li>Request</li>
          <li>Transient</li>
        </ul>
      </section>
    </section>
  </section>  
  <!-- Application life process -->
  <section>
    <header><h2>Application life process</h2></header>
    <section>
      <header>Main steps</header>
      <ol>
        <li>Application_Start WebApiConfig.Register</li>
        <li>Routing mapping (IHttpControllerSelector)</li>
      
      </ol>
    </section>
    <section>
      <header><h3>Process</h3></header>
      <pre>
      at protected void Application_Start()
      {
        GlobalConfiguration.Configure(WebApiConfig.Register); // об€зательно перед RegisterRoutes
        ...
        RouteConfig.RegisterRoutes(RouteTable.Routes); 
      }
      Web.Http.GlobalConfiguration.Configuration
      static class WebApiConfig
      {
        static void Register(HttpConfiguration config)
        {
          config.Routes.MapHttpRoute();
        }
      }
      HttpConfiguration.Formatters
      </pre>
    </section>
  </section>
  <!-- Routing -->
  <section>
    <header><h2>Routing</h2></header>
    <ol>
      <li>Conventional-base routing</li>
      <li>Attribute routing</li>
      <li>Route prefixes</li>
      <li>Route constraints</li>
      <li>CORS support</li>
      <li>Global Error handling</li>
      <li>IHttpActionResult</li>
    </ol>
    <div>Attribute routing enabled by call 
      config.MapHttpAttributesRoutes();
      in WebApiConfig.Register
    </div>
    <section>
      <h3>URL Routing</h3>
      <section>
        <h4>Classes and interfaces</h4>
        <table>
          <tbody>
            <tr><td>IHttpRoute</td><td></td></tr>
            <tr><td>HttpRoute</td><td></td></tr>
            <tr><td>IHttpRouteData</td><td>Describes the colllection of values extracted from a request when it is processed.</td></tr>
            <tr><td>HttpRouteData</td><td></td></tr>
            <tr><td>IHttpRouteConstraint</td><td>Defines a restriction that limits the requests that a route will match.</td></tr>
            <tr>
              <td>HttpRouteCollection</td>
              <td>
                This is the class with which routes are registered and which receives requests from
                the HttpRoutingDispatcher. HttpConfiguration.Routes
              </td>
            </tr>
            <tr><td>HttpRoutingDispatcher</td><td>This message handler class integrates routing into the dispacth process</td></tr>
            <tr>
              <td>RouteAttribute</td>
              <td>
                This class defines the Route attribute used to create direct routes on controller classes
                and action methods
              </td>
            </tr>
            <tr>
              <td>RouteFactoryAttribute</td>
              <td>
                This class allows custom attributes to be defined that customize the generation
                of direct routes.
              </td>
            </tr>
            <tr>
              <td>RoutePrefix</td>
              <td>
                This attribute is used to define a route template prefix that applies to all
                of the direct routes defined on a controller.
              </td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </section>
  <!-- Filter -->
  <section>
    <header><h2>Filters</h2></header>
    <section>
      <header><h3>Web API filters types and interfaces</h3></header>
      <table>
        <tbody>
          <tr>
            <td>Authentication</td>
            <td>IAutenticationFilter</td>
            <td>
              Is used to require users or clients to be
              authenticated before action methods can be executed
            </td>
          </tr>
          <tr>
            <td>Authorization</td>
            <td>IAuthorizationFilter</td>
            <td>
              Is used to restrict access to action methods
              to specific users or groups
            </td>
          </tr>
          <tr><td>Action</td><td>IActionFilter</td><td>This kind of filter is used to manipulate request or response</td></tr>
          <tr>
            <td>Exception</td>
            <td>IExceptionFilter</td>
            <td>
              This kind of filter is used to handle exceptions thrown by the
              action method or another jinf od filter.
            </td>
          </tr>
          <tr>
            <td>Override</td>
            <td>IOverrideFilter</td>
            <td>
              This kind of filter is used to tailor the behavior of other
              filtersfor individual action methods.
            </td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>
  <!-- Controller -->
  <section>
    <h2>Web API Controller</h2>
    <section>
      <h3>Process</h3>
      ApiController class relies on the IHttpActionSelector and IHttpActionInvoker interfaces to select
      and execute action methods.
      <ol>
        <li>
          The ApiController class delegates the selection of the action method for a request to an
          implementation of the IHttpActionSelector. SelectAction method uses HttpControllerContext
          and returns HttpActionDescriptor.
        </li>
        <li>
          ApiController has selectedan action method and prepared the filters
          that have been applied to it.
        </li>
        <li>
          Iterface IHttpActionInvoker is used for asynchronous call the action method. InvokeActionAsync method is
          used for call. HttpActionContext -> Task&gt;HttpResponseMessage&lt;
        </li>
        <li></li>
      </ol>
    </section>
    <section>
      <h3>Classes and interfaces</h3>
      <table>
        <tbody>
          <tr><td>System.Net.Http.HttpClient</td><td></td></tr>
          <tr><td>System.Net.Http.DelegatingHandler</td><td></td></tr>
          <tr><td>System.Net.Http.HttpResponseMessage</td><td></td></tr>
          <tr><td>System.Net.Http.HttpRequestMessage</td><td></td></tr>
          <tr><td>System.Net.Http.Formatting.MediaTypeMapping</td></tr>
          <tr><td>System.Net.Http.Formatting.MediaTypeFormatter</td></tr>
          <tr><td>System.Web.Http.ApiController</td><td>WebApi controller dispatched by HTTP verb</td></tr>
          <tr><td>System.Web.Http.IHttpActionResult</td><td></td></tr>
          <tr>
            <td>System.Web.Http.Controllers.IHttpActionSelector</td>
            <td>
              Used to identify action method
              that will be used to process the request
            </td>
          </tr>
          <tr><td>System.Web.Http.Controllers.ApiControllerActionSelector</td><td></td></tr>
          <tr><td>System.Web.Http.Controllers.HttpControllerContext</td><td>Describes contoller that is handling the request</td></tr>
          <tr><td>System.Web.Http.Controllers.HttpActionContext</td><td></td></tr>
          <tr><td>System.Web.Http.Controllers.HttpActionDescriptor</td><td></td></tr>
          <tr><td>System.Web.Http.ModelBinding.IModelBinder</td><td></td></tr>
          <tr><td>System.Web.Http.ModelBinding.ModelBindingContext</td><td></td></tr>
          <tr><td></td><td></td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>Context properties defined by the ApiController class</h3>
      <table>
        <tbody>
          <tr><td>Configuration</td><td>HttpConfiguration provides information about configuration of the application</td></tr>
          <tr><td>ControllerContext</td><td>System.Web.Http.Controllers.HttpControllerContext object that was passed to the controllers ExecuteAsync method</td></tr>
          <tr><td>ModelState</td><td>Object used for model binding validation</td></tr>
          <tr><td>Request</td><td>System.Net.Htpp.HttpRequestMessage that describes the current request</td></tr>
          <tr><td>RequestContext</td><td>System.Web.Http.Controllers.HttpRequestContext provides Web-API specific information about the current request</td></tr>
          <tr><td>User</td><td>System.Security.Principal.IPrincipal returns details of the user associated with the current request.</td></tr>
          <tr><td></td><td></td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>The properties and methods defined by the HttpACtionDescriptor class</h3>
      <table>
        <tbody>
          <tr><td>ActionBinding</td><td></td></tr>
          <tr><td>ActionName</td><td></td></tr>
          <tr><td>Configuration</td><td></td></tr>
          <tr><td>ControllerDescriptor</td><td></td></tr>
          <tr><td>ExecuteAsync</td><td></td></tr>
          <tr><td>GetCustomAttributes</td><td></td></tr>
          <tr><td>GetFilterPipeline</td><td></td></tr>
          <tr><td>GetFilters</td><td></td></tr>
          <tr><td>GetParameters</td><td></td></tr>
          <tr><td>ResultConverter</td><td></td></tr>
          <tr><td>ReturnType</td><td></td></tr>
          <tr><td>SupportedHttpMoethods</td><td></td></tr>
        </tbody>
      </table>
    </section>
  </section>
  <!-- Parameter binding -->
  <section>
    <h2>Parameter bindings</h2>
    ÷елью присоединени€ параметров €вл€етс€ нахождение экземпл€ра
    класса HttpParameterBinding дл€ каждого параметра метода Action контроллера
    <section>
      <h3>Classes and interfaces</h3>
      <table>
        <tbody>
          <tr>
            <td>HttpParameterDescriptor</td>
            <td>This class is used to describe the parameter for which Web API is looking for a binding.</td>
          </tr>
          <tr>
            <td>HttpParameterBinding</td>
            <td>Used for caching information about parameter bindings</td>
            <td><span class="code">ParameterBindingAttribute(HttpParameterDescriptor)->HttpParameterBinding</span></td>
          </tr>
          <tr>
            <td>ParameterBindingAttribute</td>
            <td>Abstract base class for all binding attributes</td>
            <td><span class="code">HttpParameterBinding GetBinding(HttpParameterDescriptor param)</span></td>
          </tr>
          <tr><td>ModelBinderAttribute</td></tr>
          <tr>
            <td>ValueProviderAttribute</td>
            <td>can be applied to attributes so that values are obtained through a value provider factory</td>
            <td>
              <span class="code">
                public string SumNumbers(Numbers numbers, [ValueProvider(typeof(HeaderValueProviderFactory))] string accept)
              </span>
            </td>
          </tr>
          <tr>
            <td>ValueProviderFactory</td>
            <td>Represents a factory for creating value-provider objects (IValueProvider)</td>
          </tr>
          <tr>
            <td>IValueProvider</td>
            <td>Defines the methods that are required for a value provider in ASP.NET MVC</td>
          </tr>
          <tr>
            <td>IActionValueBinder</td>
            <td></td>
          </tr>
          <tr>
            <td>DefaultActionValueBinder</td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>ParameterBinding attributes</h3>
      <table>
        <tr>
          <td>FromUri</td>
          <td>
            The FromUri attribute excludes any value provider factory class
            that does not implement the IUriValueProviderFactory interface
          </td>
          <td><span class="code">actionMethod([FromUri]param1, [FromUri]param2)</span></td>
        </tr>
        <tr>
          <td>FromBody</td>
          <td>Only one attribute per an action method</td>
          <td><span class="code">actionMethod([FromBody]param)</span></td>
        </tr>
        <tr>
          <td>Binding rule</td>
          <td>Applies to all parameters of given type</td>
          <td>
            <span class='code'>
              config.ParameterBindingRules.Add(typeof(Numbers),
              x => x.BindingWithAttribute(new FromUriAttribute()))
            </span>
          </td>
        </tr>
        <tr>
          <td>ParameterBindingAttribute</td>
          <td>
            If the attribute is on a type-declaration, then it's as if that attribute
            is present on all action parameters of that type.
          </td>
        </tr>
        <tr>
          <td>ModelBinderAttribute</td>
          <td>This can optionally specify the specific model binder and value providers that drive that model binder.</td>
          <td><span class="code">ModelBinderAttribute->GetValueProviderFactories->ValueProviderFactory->IValueProvider</span></td>
        </tr>
        <tr>
          <td>ValueProviderAttribute</td>
          <td>This attribute is used to specify a custom System.Web.Http.ValueProviders.ValueProviderFactory.</td>
          <td><span class="code">ValueProviderAttribute->ValueProviderFactory->IValueProvider</span></td>
        </tr>
      </table>
    </section>
    <section>
      <h3>Parameter binding process</h3>
      <table>
        <tbody>
          <tr><td>Checks to see whether a model binding attribute has been applied directly to the attribute.</td></tr>
          <tr><td>Looks for a parameter binding rule</td></tr>
          <tr><td>Acts as though the parameter has been decorated with the FromUri attribute</td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>Default sequence of parameter bindings</h3>
      Default sequence that yields an HttpParameterBinding object for a single parameter
      <table>
        <tbody>
          <tr>
            <td>1</td>
            <td>
              If the parameter has been decorated with a subclass of the ParameterBindingAttribute,
              then call the attribute's GetBinding method
            </td>
          </tr>
          <tr><td>2</td><td>Try to obtain an HttpParameterBinding object from the parameter binding rules collection</td></tr>
          <tr><td>3</td><td>For simple types, process as though the FromUri attribute has been applied to the parameter</td></tr>
          <tr><td>4</td><td>For complex types, proceed as though the FromBody attribute has been applied to the parameter</td></tr>
        </tbody>
      </table>
    </section>

    <section>
      <h3>Value Providers and Factory</h3>
    </section>
    <section>
      <h3>Model binders</h3>
      A model binder is a class responsible for using one or more values from the value providers
      to create an instance of the model type, which is used as an argument when invoking the action method.
      Using value providers means that data values are obtained from the URL
      <section>
        <h4>Classes and interfaces</h4>
        <table>
          <tr><td>HttpActionContext</td><td>Contains information for the executing action.</td></tr>
          <tr><td>ModelBindingContext</td><td>Provides the context in which a model binder functions.</td></tr>
          <tr><td>IModelBinder</td><td></td></tr>
        </table>
      </section>
      <section>
        <h4>Cusotm Model Binder</h4>
        <table>
          <tr>
            <td>Loosely coupled </td>
            <td>
              try to bind any complex action method parameter, but the limitation of this approach is
              that they canТt deal with classes that have constructor parameters or require special configuration.
            </td>
          </tr>
          <tr>
            <td>Tightly  coupled </td>
            <td></td>
          </tr>
        </table>
      </section>
      <section>
        <h4>The built-in model binder classes</h4>
        <table>
          <tbody>
            <tr><td>ArrayModelBinder</td><td>Binds an array of objects</td></tr>
            <tr><td>CollectionModelBinder</td><td>Binds a strongly typed List or Enumerable.</td></tr>
            <tr><td>DictionaryModelBinder</td><td>Bins key-value pairs to a strongly typed dictionary</td></tr>
            <tr><td>MutableObjectModelBinder</td><td>Binds object</td></tr>
            <tr><td>TypeConverterModelBinder</td><td>Binds objects using a type converter</td></tr>
          </tbody>
        </table>
      </section>
      <section>
        <h4>Custom model binders</h4>
        <ul>
          <li>The ModelBinder attribute applied to the action method parameter</li>
          <li>
            The ModelBinder attribute applied to the model class <code>
              config.Services.Insert(typeof(ModelBinderProvider), 0,
              new SimpleModelBinderProvider(typeof(Numbers), new NumbersBinder()))
            </code>
          </li>
          <li>
            A parameter binding rule
            <ul>
              <li>
                <code>config.Services.Insert(typeof(ModelBinderProvider), 0, new SimpleModelBinderProvider(typeof(Numbers), new NumbersBinder()))</code>
              </li>
            </ul>
          </li>
        </ul>
      </section>
    </section>
    <section>
      <h3>Manual binding</h3>
      <div>
        <span class="code">Request.GetQueryNameValuePairs(x=>x.Key, x=>x.Value)</span>
      </div>

    </section>
    <section>
      <h3>Type converters</h3>
    </section>
  </section>
  <!-- Media type formatters -->
  <section>
    <header><h2>Media type formatters</h2></header>
    <section>
      <h3>Classes and interfaces</h3>
      <table>
        <tbody>
          <tr><td>System.Net.Http.HttpContent</td></tr>
          <tr><td>System.Net.Http.Formatting.MediaTypeFormatter</td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <header><h3>Built-in media type formatters</h3></header>
      <table>
        <thead>
          <tr><td>MIME Types</td><td>Media type formatter</td></tr>
        </thead>
        <tbody>
          <tr><td>application/json, text/json</td><td>JsonMediaTypeFormatter</td></tr>
          <tr><td>application/xml, text/json</td><td>XmlMediaTypeFormatter</td></tr>
          <tr><td>application/x-www-form-urlencoded</td><td>FormUrlEncodedMediaTypeFormatter</td></tr>
          <tr><td>application/x-www-form-urlencoded</td><td>JQueryMvcUrlEncodedTypeFormatter</td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <header><h3>Custom media type formatters</h3></header>
      <ol>
        <li>Create class derived from MediaTypeFormatter</li>
        <li>Register through config.Formatters.Add(new CustomFormatter())</li>
        <li>
          When a request arrives, the MIME type in the Content-Type header selects
          the media type formatter that can handle that type
        </li>
      </ol>
    </section>
  </section>
  <!-- Method results -->
  <section>
    <h2>Method Results</h2>
    <section>
      <h3>Tasks</h3>
      <ol>
        <li>Define an action method that doesn't return any data</li>
        <li>Action method that returns a result</li>
        <li>Select the data format that will be used for serialized data</li>
        <li>Register a content negotiation class</li>
        <li>Specify a result code to be used in a response that contains serialized data</li>
        <li></li>
      </ol>
    </section>
    <section>
      <h3>Termins</h3>
      <table>
        <tbody>
          <tr>
            <td>Content negatiation</td>
            <td>Process of examining request and identifying the format that best suits the client.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>Process</h3>
      Client -> Hosting (Request) -> Controller (HttpRequestMessage) -> Action (HttpRequestMessage + Model)
      Action -> Controller (Result) -> Hosting (HttpResponseMessage) -> Client (Response)
    </section>
    <section>
      <h3>Classes and interfaces</h3>
      <table>
        <tbody>
          <tr><td>System.Net.Http.HttpRequestMessage</td></tr>
          <tr><td>System.Net.Http.HttpResponseMessage</td></tr>
          <tr>
            <td>System.Web.Http.IHttpActionResult</td>
            <td>used for separation an action method from HttpResponseMessage object</td>
          </tr>
          <tr><td>System.Net.Http.Controllers.IActionResultConverter</td></tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>Using the ApiController Action results methods</h3>
      <table>
        <tbody>
          <tr><td>BadRequest</td></tr>
          <tr><td>Content</td></tr>
          <tr><td>Created</td></tr>
          <tr><td>OK</td></tr>
          <tr><td>Redirect</td></tr>
          <tr><td>ResponseMessage</td></tr>
          <tr><td>Unauthorized</td></tr>
        </tbody>
      </table>
    </section>
    
    <section>
      <header><h2>Dispatching</h2></header>
      <section>
        <h3>Classes and interfaces</h3>
        <table>
          <tbody>
            <tr><td>HttpServer</td><td>The first message handler to receive new HttpRequestMessage objects</td></tr>
            <tr><td>HttpRoutingDispatcher</td><td>The second message handler, which creates routing data for the request</td></tr>
            <tr>
              <td>HttpControllerDispatcher</td>
              <td>
                The third and final message handler, which selects, activates and executes a controller
                to create an HttpResponseMessage object. Delegates the selection of the controller class to an implementation fo the
                System.Web.Http.Dispatcher.IHttpControllerSelector.
              </td>
            </tr>
            <tr>
              <td>IHttpControllerSelector</td>
              <td>
                The interface that the HttpControllerDispatcher class uses to
                delegate controller selection. The default implementation is the DefaultHttpControllerTypeResolver.
                Method GetContollerMapping returns a collection of all the contollers that are available in the application.
                During application startup, DefaultHttpControllerSelector builds a list of all the controller classes in
                the application, which is later used as the basis for selectinga controller to handle each request.
              </td>
            </tr>
            <tr>
              <td>System.Web.Http.Dispatcher.IHttpControllerTypeResolver</td>
              <td>
                Defines the GetControllerTypes method,
                which is required to return a collection of all the controller types in the application
              </td>
            </tr>
            <tr>
              <td>IAssembliesResolver</td>
              <td>
                The interface used to resolve assemblies in the application so that the
                IHttpControllerTypeResolver implementation can search them for controllers. The default implementation is
                the DefaultAssembliesResolver class.
              </td>
            </tr>
            <tr>
              <td>IHttpControllerActivator</td>
              <td>
                Used by the HttpControllerDispatcher class to delegate creating an instance
                of the selected controller. The default implementation is the DefaultHttpControllerActivator.
              </td>
            </tr>
            <tr><td>IHttpController</td><td>The interface used to denote controller</td></tr>
            <tr>System.Web.Http.Controllers.HttpControllerDescriptor<td></td><td></td></tr>

            <tr><td></td><td></td></tr>
          </tbody>
        </table>
      </section>
      <section>
        <h3>Process</h3>
        The HttpServer class receives requests from the hosting environment, the HttpRoutingDispatcher
        integrates URL routing, and the HttpControllerDispatcher selects a controller to handle the request.
        HttpControllerDispatcher obtains HttpControllerDescriptor object that describes the controller that
        will handle the request. The next step is to instantiate the controller class, a process known
        as <i>activation</i>, which do by calling Create method.
        <section>
          <h4>URL routing system</h4>
          Has one purpose: to inspect the request in order to produce data that other components will need
          to process further along the message handler chain. Produced data is called <i>routing data</i> or <i>route data</i>
          Routing data is typically used to extract three types of data from a request
          <ul>
            <li>The name of controller</li>
            <li>The name of an action method</li>
            <li>Values that can be used for parameter binding</li>
          </ul>
        </section>
      </section>
    </section>


    <section>
      <h2>Model Validation</h2>
      <section>
        <h3>Termins</h3>
        under-posting, over-posting, unusable data
      </section>
      <section>
        <h3>The built-in validation attributes</h3>
        <table>
          <tbody>
            <tr><td>Compare</td></tr>
            <tr><td>CreditCard</td></tr>
            <tr><td>Email</td></tr>
            <tr><td>Enum</td></tr>
            <tr><td>MaxLength</td></tr>
            <tr><td>MinLength</td></tr>
            <tr><td>Range</td></tr>
            <tr><td>RegularExpression</td></tr>
            <tr><td>Required</td></tr>
            <tr><td>StringLength</td></tr>
          </tbody>
        </table>
      </section>
    </section>
  </section>
  <!-- Security -->
  <section>
    <h2>Security</h2>
    <section>
      <h3>[Authorize] attributes</h3>
      <section>
        <h3>Interfaces</h3>
        <ol>
          <li>AuthorizeAttribute. Extend this class to perform authorization logic based on the current user and the userТs roles.</li>
          <li>AuthorizationFilterAttribute. Extend this class to perform synchronous authorization logic that is not necessarily based on the current user or role.</li>
          <li>IAuthorizationFilter. Implement this interface to perform asynchronous authorization logic; for example, if your authorization logic makes asynchronous I/O or network calls. (If your authorization logic is CPU-bound, it is simpler to derive from AuthorizationFilterAttribute, because then you donТt need to write an asynchronous method.)</li>
        </ol>
      </section>
      <section>
        <h4>Using</h4>
        You can apply this attribute globally, at the controller level, or at the level of inidivual actions.
        <ol>
          <li>
            <span class="code">
              public static void Register(HttpConfiguration config)
              {
                config.Filters.Add(new AuthorizeAttribute());
              }
            </span>
          </li>
          <li>
            <span class="code"><pre>
              // Require authorization for all actions on the controller.
              [Authorize]
              public class ValuesController : ApiController
              {
                public HttpResponseMessage Get(int id) { ... }
                public HttpResponseMessage Post() { ... }
              }
            </pre></span>
          </li>
          <li>
            <span class="code">
              public class ValuesController : ApiController
              {
                public HttpResponseMessage Get() { ... }
                // Require authorization for a specific action.
                [Authorize]
                public HttpResponseMessage Post() { ... }
              }
            </pre></span>
          </li>
        </ol>
      </section>
    </section>
  </section>
</body>
</html>
